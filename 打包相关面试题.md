## 使用webpack手动搭建react开发环境，聊一聊你的思路。

首先要安装webpack与webpack-cli，编写webpack.config.js文件，常规4部分，入口（entry）、出口（output）、loader、plugins。

需要对js、jsx后缀的文件进行编译，就需要balel，npm 安装 ```@babel/cli``` ```@babel/core``` ```@babel/preset-env``` ```babel-loader```

```@babel/preset-react```

还需要css的loader，安装```style-loader``` ```css-loader```

还有常用的plugins，例如：```html-webpack-plugin```  用来生成HTML文件  ```clean-webpack-plugin```  清理dist目录

## 常用的webpack loaders、plugins有哪些？如何自定义loader、plugin？

**plugins:**

```html-webpack-plugin```  用来生成HTML文件 

```clean-webpack-plugin```  清理dist目录

```purifycss-webpack``` 去除未被使用的css代码

```uglifyjs-webpack-plugin``` uglifyjs 用于压缩 js，支持文件缓存，和多线程压缩。

**loader:**

```style-loader``` ```css-loader```

```file-loader```

```sass-loader```

```babel-loader```

```eslint-loade```

## 谈一谈webpack、gulp  、vite这三者之间的差异。

vite是基于ECMAscript的ES Module实现的，使用expor import导入导出在， script 标签里设置type="module"，然后使用模块内容。

webpack和vite的区别在于，webpack会预编译先build一遍，随着项目越来越大，bundle也越来越大，速度也就慢了下来。Vite 通过在

一开始将应用中的模块区分为 **依赖** 和 **源码** 两类，改进了开发服务器启动时间。

对于**依赖**来说，大多都是不怎么会改变的，因此对于这部分代码，vite会使用esbuild预构建依赖，esbuild使用了Go编写，速度很快。

对于**源码**，一般为非js文件，需要转换，例如jsx，css，vue等，vite交给浏览器来处理，当前使用到哪一段源码，才动态的导入并转换。

## 什么Babel？常用的babel有哪些？

Babel是一个工具链，将一些比较新的语法，自动转化为先后兼容的代码。

用官方的预设

- @babel/preset-env 用于编译 ES2015+ 语法
- @babel/preset-typescript 用于 [TypeScript](https://www.typescriptlang.org/)
- @babel/preset-react 用于 [React](https://reactjs.org/)
- @babel/preset-flow  用于 [Flow](https://flow.org/)

## 谈一谈你对Eslint的理解，工作中遇到Eslint问题有哪些解决方案？

Eslint是用来规范项目中的代码规范，使的团队开发风格尽量统一，一般工作中出现报错分为，代码错误与eslint报错，刚开始准备写代码时可以先创建eslintingore来暂时忽略eslint报错，但在代码提交之前一点要把eslint检查打开，一步步的将不合规的代码修复好，修改到不再报错再提交，不清楚的报错规则就去eslint官网搜索一下。开发中可以安装eslint插件，提高开发效率。

## 谈一谈你对TS的理解，常用的TS类型有哪些？

typescript是JavaScript的超集，对js这样的弱类型语言加上了强类型语言的补丁，我们可以明确的声明每一个变量的类型，虽然对比起js来说麻烦了一点，但在大型项目中可以很好的避免bug的出现，还有助于团队间的合作，因为类型清晰明确了。

常见的TS类型有：

- string

- number

- boolean

- any  (有传染性)

- unknown （类似any，但无传染性）

- enum 枚举

- 数组

  1. eg：string[] , number[]  直接在元素上加 [ ]
  2. Array<String> 数组泛型方式

- 元组

  ​	`let a: [string, Boolean]; a = ['LiMing', false]; // OK`

- 断言  

  ​    1.<string>  let strLength: number = (<string>someValue).length;

  ​    2.as 语法 let strLength: number = (someValue as string).length;

## 解决“浏览器同源策略阻止跨域请求”的常用方案及其原理。

## Vue/React项目打包上线，为什么需要给文件名添加hash字符串。进一步谈一谈什么浏览器的强缓存、协商缓存。

给文件名添加hash字符串，用来区分文件是否缓存了。文件内容产生改变，文件名的hash值必然会改变，若hash值不变，则使用缓存。

在浏览器中一个很常见的HTTP状态码 `304 not Modified`,资源未改变，可以使用缓存的资源。这里涉及到浏览器的**强缓存**与**协商缓存**

在浏览器第一次请求后，如果需要再一次发送请求，会先检查资源的header头信息，根据其中的Cache-Control与expires来判断是否过期，如果未过期，则使用缓存资源，过期了就向服务器发送请求，并携带着有关缓存的header字段，

